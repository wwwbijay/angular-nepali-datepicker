{"version":3,"file":"ngcc-cache.js","sourceRoot":"","sources":["../../../src/lib/ng-package/ngcc-cache.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;;GASG;AACH,MAAa,mBAAmB;IAG9B;QAFiB,yBAAoB,GAAG,IAAI,GAAG,EAAU,CAAC;QAGxD,IAAI,CAAC,QAAQ,EAAE,CAAC;IAClB,CAAC;IAEO,QAAQ;QACd,iBAAiB;QACjB,uFAAuF;QACvF,4GAA4G;QAC5G,gEAAgE;QAChE,KAAK,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE;YACnC,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;SACpC;IACH,CAAC;IACD,YAAY,CAAC,UAAkB;QAC7B,OAAO,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IACnD,CAAC;IAED,aAAa,CAAC,UAAkB;QAC9B,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;IAC5C,CAAC;IAED,KAAK;QACH,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,CAAC;QAClC,IAAI,CAAC,QAAQ,EAAE,CAAC;IAClB,CAAC;CACF;AA5BD,kDA4BC","sourcesContent":["/**\n * Registers the absolute specifiers of libraries that have been processed by ngcc. This cache is\n * reused across all entry-points of a package, so module requests across the entry-points can\n * determine whether invoking ngcc is necessary.\n *\n * The cost of invoking ngcc for an entry-point that has already been processed is limited due to\n * a fast path in ngcc, however even in this fast-path does ngcc scan the entry-point to determine\n * if all dependencies have been processed. This cache allows to avoid that work, as entry-points\n * are processed in batches during which the `node_modules` directory is not mutated.\n */\nexport class NgccProcessingCache {\n  private readonly processedModuleNames = new Set<string>();\n\n  constructor() {\n    this.populate();\n  }\n\n  private populate() {\n    // Workaround for\n    // [DEP0148] DeprecationWarning: Use of deprecated folder mapping \"./\" in the \"exports\"\n    // field module resolution of the package at /Users/alanagius/git/ng-packagr/node_modules/chai/package.json.\n    // Update this package.json to use a subpath pattern like \"./*\".\n    for (const lib of ['chai', 'tslib']) {\n      this.processedModuleNames.add(lib);\n    }\n  }\n  hasProcessed(moduleName: string): boolean {\n    return this.processedModuleNames.has(moduleName);\n  }\n\n  markProcessed(moduleName: string): void {\n    this.processedModuleNames.add(moduleName);\n  }\n\n  clear(): void {\n    this.processedModuleNames.clear();\n    this.populate();\n  }\n}\n"]}